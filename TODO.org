Done:
    Entity == [Component]
    Component == [Message Handler] | [Reactor]

    Messages are sent to Entities, and passed to Components (e.g. [:entity/player :event.stats/damage {:amount 40 :type :physical}] {:component/stats {...}})
    You can add middleware to components {:middleware.stats/defense (fn [entity event] (update event :defense #(- % (-> entity :component/equipment :defense)))) }
    Reactors react when an entity changes (:reactor.stats/dead? (when (zero? (:hp stats)) "dead"))
       Reactors can also be attached to a component, but listen to delta / time (Or should that be something completely different?)

* DONE Add, Remove middleware

Should we be able to add / remove middleware? Or should it always be pre-defined
and the component state should decide whether or not it's activated?
* DONE Add, Remove tickers
Add tickers. These are "handlers" that reacto to delta/time
* TODO Link - fn ; Links can be attached to handlers, to extend "generic"
Do we really need this?
* DONE How do we make components more modular between entities?
Currently in order to re-use a component, we need to re-define it for each
entity, and define all its handlers, reactors, and tickers, even if there are
default handlers. Also if you have a collection of monsters (group), they will
reuse the same component.
** SOLUTION
Each entity is its own system. Init with all their required components. ~Also use
prep-key on components to reference default handler / reactors etc~
Look at DONE: Overriding component defaults
* TODO Use local hierarchies create inheritence
For example:
Entity Hierarchy
#+BEGIN_SRC clojure
{:entity.group/monster [:component/movable]
 :entity.group/fire-monster [:entity.group/monster]
 :entity/fire-crawler [:entity.group/fire-monster]}
#+END_SRC

* TODO separate system and state
Currently we have a specification map of our game. then we init each entity +
scene. State and config get intertwined, Maybe we can separate these concerns.
For example have the system map, and a db map, which contains a collection of
all entities, scenes. Maybe map per scene? Maybe have enties in their own map,
as a table?

* TODO Think of a way to create abstraction layers
How do we create a abstraction/position? If a component wants to be position
(Sprite, Physics body), they need to implement an interface. For example

position/set-position

[:component/rectangle Component Body] event-> [:position/set-position [:exclude :component/rectangle]]

Now the all components of the entity will call the :position/set-position
implementation, exception for the sender (rectangle)

* DONE Overriding component defaults
Maybe we can merge component opts by retrieving the parents opts in the base
config. We need to
* DONE When merging components, change the component key in the base config to the new key
* TODO Add exclude/handler exclude/ticker exclude/reactor exclude/middleware?
Allow entities to exclude certain parts of a component, that would allow for
overriding. How do we exclude middleware? Since it's part of handlers.
